# Задача 2
## Цели

- Познакомиться со стратегией уникального владения рессурсом
- Получить базовые знания о *move-семантике*
- Освоить принцип *const as much as possible*

## Условие

Доработать класс умного указателя `UniqPtr` из [задачи 1](https://bitbucket.org/750503/lr3_repo/src/master/1/) так, чтобы он поддерживал семантику перемещения.

**Класс должен удовлетворять слующим дополнительным требованиям:**

- Копирование все еще запрещено
- Операция перемещающего присваивания разрешена и не допускает утечки памяти
- Есть конструктор перемещения, выполняющий деструктивное копирование (это и есть перемещение)
- Деструктор должен автоматически очищать память
- Есть метод `Release()` отвязывающий хранимый указатель от объекта без освобождения памяти. При отвязывании, умный указатель "забывает" о том, что хранил.

## Требования к решению

В папке с условием есть файлы `main.cpp, tree.h, tree.cpp`. Файл `tree.h` подключает отстутвующий файл `uniq_ptr.h`. Ваша задача написать `uniq_ptr.h` так, чтобы программа скомпилировалась и корректно завершилась с сообщением `The happy end!`. При этом должны быть выполнены условия в комментариях к коду.в `main.cpp`

В сравнении с первым заданием, файлы претерпели небольшие изменения: появился метод `erase(key)` удаляющий узел дерева. Его нельзя было реализовать без move-семантики. В `main.cpp` появились дополнительные варианты использования указателей.  
