# Задача 3 (ад с итераторами)
## Цели

- Укрепить знания о перегрузке операторов
- Научиться писать std-совместимый код
- Освоить принцип *const as much as possible*
- Познакомиться с ключевым словом `friend`

## Условие

Написать класс Range, представляющий последовательность значений `int`, задаваемую первым значением, максимальным значением и шагом.

1. Общие требования:
    - **Класс не должен хранить массивов!**, i-ый элемент последовательности вычисляется на ходу. 
    - Использовать деструктор, операции копирования и перемещения по умолчанию (можно вовсе не объявлять, компилятор сгенерирует их).
    - Нужны конструкторы только с параметрами: начало, конец и шаг последовательности. 
    - Если не указывать шаг, его значение по умолчанию считать за 1.
    - Последовательность не сходится, если шаг равен нулю или не соотвтетвует по знаку направлению последовательности. В этом случае выбросить исключение.
    - При инициализации считать последним элементом максимальное возможное число в пределах от начала до конца, получаемое прибавлением шага к начальному элементу.
    - Объявление своих классов делать в `namespace ranges`.
    
2. Методы и операторы:

    - `first()` - возвращает первый элемент последовательности.
    - `last()` - возвращает последний допустимый элемент последовательности.
    - `size()` - возвращает количество допустимых элементов последовательности.
    - `begin()` - возвращает итератор на первый элемент последовательности.
    - `end()` - возвращает итератор на элемент, следующий за последним элементом последовательности.
    - `rbegin()` - возвращает обратный итератор на первый с конца элемент последовательности. 
    - `rend()` - возвращает обратный итератор на элемент, следующий за последним с конца элементом последовательности.
    - `operator[]` - возвращает i-ый элемент последовательности без проверки на границы. При нарушении границ - *undefined behavior* (то есть, поведение остается на ваше усмотрение или неусмотрение).

    **Важно!** Поскольку класс не владеет данными, он работает только на чтение. В связи с этим внимательно отнеситесь к модификатору `const` для методов и их параметров.

3. Итераторы:

    - Итераторы должны поддерживать следующие операции: `i==i, i!=i, i>i, i<i, i>=i, i<=i, i++, ++i, i--, --i`.
    - Итераторы можно только копировать и перемещать. Конструировать их может только класс `Range` (да, это намек на то, что конструктор итератора должен быть `private`, а сам класс итератора должен объявить `Range` как `friend`).
    - Сравнение итераторов разных экземпляров `Range` - невалидная операция, в этом случае нужно кидать исключение.
    - **Don't repeat youself**: оператор `!=` можно получить на основе `==`, а операторы `>, >=, <=` - на основе `<`. Преинкремент и постинкремент также связаны.
    - **Don't repeat youself**: реверс-версия итератора может быть получена небольшой обвязкой над обычным итератором. Для этого пишется класс-адаптор, включающий в себя обычный итератор. В нем `*` разыменовывает *-1-ый* элемент, инкременты делают декременты, сравнения выполняют противоположиные сравнения и т.п. Есть еще `std::reverse_iterator<>`, но под него нужно адаптировать `iterator_traits`.
    - Итератор **не должен** быть вложенным классом контейнера `Range`. Это позволяет снизить зависимости между экземплярами `Range` и получить болеее гибкий код;
    - Вместо этого, класс `Range` в своей `public` секции объявляет псевдоним `iterator` с помощью директивы `using` (раньше использовался `typedef`, но он подустарел). То же и с `reverse_iterator`.
    - Если последовать совету выше, скорее всего, возникнет циклическая зависимость между итератором и контейнером. Это нормально: итератор должен знать внутренности контейнера, а контейнер должен знать что-то про итератор. Чтобы распутать клубок, сделайте следующее:
    ```cpp

    //<.h-файл>
    class Iterator
    {
        //Тут только прототипы
    };

    сlass Range
    {
        //Тут прототипы и встраиваемые методы
    };

    //<.cpp-файл>
    // Определения всех методов Iterator
    
    //Определения длинных методов Range
    ```
    Это распутает клубок, так как вынесение определения метода в *.cpp*-файл делает его невстраеваемым, и, следовательно, классы могут быть скомпилированы раздельно, а потом слинкованы.
    Если оставить методы в *.h*-файле, они будут встраеваемыми. То есть все их внутренности будут известны еще на этапе компиляции, из-за чего независимо скомпилировать два класса не получится. 
    (Другой путь обхода проблемы - template, но не в этот раз)

    - **Важно!** Чтобы STL воспринимал класс вашего итератора всерьез, в нем (в `public`-секции) необходимо определить несколько псевдонимов типов (`iterator_traits`):

    ```cpp
    using iterator_category = std::bidirectional_iterator_tag; //#include <iterator>
    using value_type = int;
    using difference_type = int;
    using pointer = int*;
    using reference = int&;
    ```
    При запуске тестов обратите внимание, что валится, если этого не написать ;)

4. Тесты:

    - Менять файл `main_range.cpp` и `reverse.h` без абсолютно веских причин нельзя (только если в целях отладки, но потом все верните назад)! В случае возникновения вопросов - спрашивайте меня лично.
    - Ваша задана написать файлы `range.h` и `range.cpp`, так, чтоб программа прошла все тесты из `main`. 
    - Раскомментирование любой закомментированной строчки должно приводить к ошибке компиляции.
    - Прошу прощения за не самые читаемые тесты, я старался минимизировать количество повтора кода.
    - Проходите тесты постепенно, комментируя неинтересные на текущий момент. Но, увы, многие тесты, так что реализовывать и тестировать придется по несколько фич сразу. Совершенно не обязательно проходить тесты сверху вниз.
    - Чтобы понять, где валится тест, легче использовать отладчик. На консоль выводится номер теста, где стоит поставить брейк-пойнт.
    - Готовьтесь, что будет очень много ошибок компиляции. Комментируйте тесты, пока не заработает. Если это не приводит вас к решению проблемы - гуглите, спрашивайте друзей, пишите мне)
    
    
## Вспомогательный материал
- [Почитайте решение 3.1](https://7bit.net.ru/download/5853/inline/%D0%A1%D0%B0%D1%82%D1%82%D0%B5%D1%80%20%D0%93.%20-%20%D0%A0%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D1%8B%D1%85%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%20%D0%BD%D0%B0%20C++%20(2008).pdf#page=175)
